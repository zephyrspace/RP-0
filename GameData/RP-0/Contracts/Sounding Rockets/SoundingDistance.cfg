CONTRACT_TYPE
{
	name = SoundingRocketDistance1
	group = SoundingRockets
	sortKey = 991

	// ************ REQUIREMENTS ************
	REQUIREMENT
	{
		name = AltitudeRecord100k // Karman line
		type = AltitudeRecord
		minAltitude = 100000
		title = Must have reached 100 km
	}
	REQUIREMENT
	{
		name = AcceptContract
		type = AcceptContract
		checkOnActiveContract = true
		invertRequirement = true
		contractType = SoundingRocketDistance2
		title = Do not accept @contractType
	}

	// ************ CONTRACT DATA ************
	DATA 
	{
		type = float
		index = RP0SoundingDistanceIndex1
	}
	BEHAVIOUR
	{
		name = IncrementIndex
		type = Expression
		CONTRACT_COMPLETED_SUCCESS
		{
			RP0SoundingDistanceIndex1 = RP0SoundingDistanceIndex1 + 1
		}
	}
	DATA
	{
		type = List<float>
		distances = [ 100, 150, 200, 250, 300 ]
	}
	DATA
	{
		type = float
		payload = 2000
		baseReward = 4000
	}
	DATA
	{
		type = string
		numeral = "I"
	}
}
CONTRACT_TYPE
{
	name = SoundingRocketDistance2
	group = SoundingRockets
	sortKey = 992

	// ************ REQUIREMENTS ************
	REQUIREMENT
	{
		name = CompleteContract
		type = CompleteContract
		contractType = SoundingRocketDistance1
		title = Complete @contractType
	}
	REQUIREMENT
	{
		name = AcceptContract
		type = AcceptContract
		checkOnActiveContract = true
		invertRequirement = true
		contractType = SoundingRocketDistance3
		title = Do not accept @contractType
	}

	// ************ CONTRACT DATA ************
	DATA 
	{
		type = float
		index = RP0SoundingDistanceIndex2
	}
	BEHAVIOUR
	{
		name = IncrementIndex
		type = Expression
		CONTRACT_COMPLETED_SUCCESS
		{
			RP0SoundingDistanceIndex2 = RP0SoundingDistanceIndex2 + 1
		}
	}
	DATA
	{
		type = List<float>
		distances = [ 300, 400, 500, 600, 700 ] 
	}
	DATA
	{
		type = float
		payload = 2000
		baseReward = 6000
	}
	DATA
	{
		type = string
		numeral = "II"
	}
}
CONTRACT_TYPE
{
	name = SoundingRocketDistance3
	group = SoundingRockets
	sortKey = 993

	// ************ REQUIREMENTS ************
	REQUIREMENT
	{
		name = CompleteContract
		type = CompleteContract
		contractType = SoundingRocketDistance2
		title = Complete @contractType
	}
	REQUIREMENT
	{
		name = AcceptContract
		type = AcceptContract
		checkOnActiveContract = true
		invertRequirement = true
		contractType = SoundingRocketDistance4
		title = Do not accept @contractType
	}

	// ************ CONTRACT DATA ************
	DATA 
	{
		type = float
		index = RP0SoundingDistanceIndex3
	}
	BEHAVIOUR
	{
		name = IncrementIndex
		type = Expression
		CONTRACT_COMPLETED_SUCCESS
		{
			RP0SoundingDistanceIndex3 = RP0SoundingDistanceIndex3 + 1
		}
	}
	DATA
	{
		type = List<float>
		distances = [ 400, 500, 600, 800, 900 ] 
	}
	DATA
	{
		type = float
		payload = 4000
		baseReward = 10000
	}
	DATA
	{
		type = string
		numeral = "III"
	}
}
CONTRACT_TYPE
{
	name = SoundingRocketDistance4
	group = SoundingRockets
	sortKey = 994

	// ************ REQUIREMENTS ************
	REQUIREMENT {
		name = CompleteContract
		type = CompleteContract
		contractType = SoundingRocketDistance3
		title = Complete @contractType
	}

	// ************ CONTRACT DATA ************
	DATA 
	{
		type = float
		index = RP0SoundingDistanceIndex4
	}
	BEHAVIOUR
	{
		name = IncrementIndex
		type = Expression
		CONTRACT_COMPLETED_SUCCESS
		{
			RP0SoundingDistanceIndex4 = RP0SoundingDistanceIndex4 + 1
		}
	}
	DATA
	{
		type = List<float>
		distances = [ 1600, 1800, 2000, 2200, 2400 ] 
	}
	DATA
	{
		type = float
		payload = 2000
		baseReward = 16000
	}
	DATA
	{
		type = string
		numeral = "IV"
	}
}

@CONTRACT_TYPE[SoundingRocketDistance*]:FOR[00_ContractSetup]
{
	title = Class @numeral Long-Distance Suborbital Rocketry
	description = Developing rockets is hard. As your space program matures, you will need to test new heavy engines and develop vehicles capable of putting larger payloads into orbit. To that effect, design, build and launch a class @numeral sounding rocket which will deliver @payload units of payload to a minimum downrange distance of @targetDistance km. The energy required will increase with each new series of rocket. You will recieve partial rewards if you fall short of this target, and you will recieve additional reward if you exceed it.<br>The class @numeral series of downrange rockets contains four contracts, of which @index have been completed.&br;The reward of this contract will slowly increase over time but will be reset to 0 after each completion.&br;<b>Current reward is at @rewardFactorPercent % of it's nominal value. Elapsed/Expected Days: @elapsedDays / @expectedDays</b>&br;&br;<br><br><b>YOU WILL NO LONGER BE ABLE TO COMPLETE CONTRACTS OF THIS SERIES ONCE YOU ACCEPT A CONTRACT OF THE FOLLOWING SERIES. Be sure you are ready for the next challenge before accepting a contract from a new series!</b>
	genericDescription = Deliver the payload a specified distance downrange. This contract will stretch your capabilities and enable harder contracts.
	synopsis = Launch a guided sounding rocket with @payload units of payload to a downrange distance of @targetDistance km.
	completedMessage = Congratulations on a successful launch! The rocket has delivered the payload.

	minExpiry = 1
	maxExpiry = 1
	maxCompletions = 4
	maxSimultaneous = 1
	deadline = 365

	targetBody = HomeWorld()

	// ************ REWARDS ************
	DATA
	{
		type = List<float>
		advances = [	2,		1,		0.5,	0.125 ]

		rewards0 = [	1,		0.5,	0.25,	0.125 ]
		rewards1 = [	1,		1,		0.5,	0.25 ]
		rewards2 = [	1,		1,		1,		0.5 ]
		rewards3 = [	0.5,	1,		1,		1 ]
		rewards4 = [	0.25,	0.5,	1,		1 ]
	}
	DATA
	{
		type = float
		targetDistance = @distances.ElementAt(@index)
	}

	DATA
	{
		type = int
		antiGrindCompletion = $SRD_Completion == 0 ? (UniversalTime() - @expectedDays * 86400) : $SRD_Completion
	}

	DATA
	{
		type = float
		expectedDays = 130

		elapsedDays = Round((UniversalTime() - @antiGrindCompletion) / 86400.0)
		rewardFactor = Log(Max(@elapsedDays / @expectedDays * 3 - 0.05, 1), 2) / 1.5607
		rewardFactorPercent = Round(@rewardFactor * 100, 1)
	}

	prestige = Trivial
	advanceFunds = Round((@advances.ElementAt(@index) * @baseReward * (2 / 3) * @rewardFactor), 100)
	rewardFunds = Round(((@baseReward / 3) * @rewardFactor), 100)
	failureFunds = @advanceFunds * 0.5

	BEHAVIOUR
	{
		name = IncrementTheCount
		type = Expression

		CONTRACT_OFFERED
		{
			SRD_Completion = ($SRD_Completion + 0) == 0 ? (UniversalTime() - 130 * 86400) : ($SRD_Completion + 0)
		}
		CONTRACT_COMPLETED_SUCCESS
		{
			SRD_Completion = UniversalTime()
		}
	}

	// ************ PARAMETERS ************
	PARAMETER
	{
		name = VesselGroup
		type = VesselParameterGroup
		title = Reach at least @/targetDistance km with @/payload units of payload
		
		PARAMETER
		{
			name = NewVessel
			type = NewVessel
			title = Launch a New Vessel
		}
		PARAMETER
		{
			name = Crewmembers
			type = HasCrew
			minCrew = 0
			maxCrew = 0
			title = Uncrewed
			hideChildren = true
		}
		PARAMETER
		{
			name = HasSoundingPayload
			type = HasResource
			resource = SoundingPayload
			minQuantity = @/payload-0.1
			title = Have a SoundingPayload of at least @/payload units on the craft
			hideChildren = true
		}
		PARAMETER
		{
			name = NoCheese
			type = ReachState
			minAltitude = 50000
			disableOnStateChange = true
			title = Reach an altitude of at least 50 km
			hideChildren = true
		}
		PARAMETER
		{
			name = ReachDistance0
			type = DownrangeDistance
			completeInSequence = true
			distance = @/distances.ElementAt(0) * 1000
			notes = @/index==0 ? "Distance required for completion." : ""
			optional = @/index < 0
			rewardFunds = @/rewardFunds * @/rewards0.ElementAt(@/index)
			rewardReputation = @/rewardReputation * @/rewards0.ElementAt(@/index)
		}
		PARAMETER
		{
			name = ReachDistance1
			type = DownrangeDistance
			completeInSequence = true
			distance = @/distances.ElementAt(1) * 1000
			notes = @/index==1 ? "Distance required for completion." : ""
			optional = @/index < 1
			rewardFunds = @/rewardFunds * @/rewards1.ElementAt(@/index)
			rewardReputation = @/rewardReputation * @/rewards1.ElementAt(@/index)
		}
		PARAMETER
		{
			name = ReachDistance2
			type = DownrangeDistance
			completeInSequence = true
			distance = @/distances.ElementAt(2) * 1000
			notes = @/index==2 ? "Distance required for completion." : ""
			optional = @/index < 2
			rewardFunds = @/rewardFunds * @/rewards2.ElementAt(@/index)
			rewardReputation = @/rewardReputation * @/rewards2.ElementAt(@/index)
		}
		PARAMETER
		{
			name = ReachDistance3
			type = DownrangeDistance
			completeInSequence = true
			distance = @/distances.ElementAt(3) * 1000
			notes = @/index==3 ? "Distance required for completion." : ""
			optional = @/index < 3
			rewardFunds = @/rewardFunds * @/rewards3.ElementAt(@/index)
			rewardReputation = @/rewardReputation * @/rewards3.ElementAt(@/index)
		}
		PARAMETER
		{
			name = ReachDistance4
			type = DownrangeDistance
			completeInSequence = true
			distance = @/distances.ElementAt(4) * 1000
			notes = @/index==4 ? "Distance required for completion." : ""
			optional = @/index < 4
			rewardFunds = @/rewardFunds * @/rewards4.ElementAt(@/index)
			rewardReputation = @/rewardReputation * @/rewards4.ElementAt(@/index)
		}
		PARAMETER
		{
			name = ReenterAtmosphere
			type = ReachState
			maxAltitude = 50000
			title = Survive reentry at least to 50 km
			hideChildren = true
		}
	}
}
